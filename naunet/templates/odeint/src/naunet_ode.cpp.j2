#include <math.h>

#include "naunet_constants.h"
#include "naunet_macros.h"
#include "naunet_ode.h"
#include "naunet_physics.h"

/* {% set wrap = "\n        " -%} */
/* {% set bclose = wrap + "}" -%} */

using namespace boost::numeric::odeint;

int EvalRates(double *k, double *y, NaunetData *u_data) {
    // clang-format off
    {% for v in network.varis.keys() -%}
        double {{ v }} = u_data->{{ v }};
    {% endfor %}

    {% for v in network.locvars -%}
        {{ v }};
    {% endfor %}

    // clang-format on

    double Te      = Tgas * 8.617343e-5;            // Tgas in eV (eV)
    double lnTe    = log(Te);                       // ln of Te (#)
    double T32     = Tgas * 0.0033333333333333335;  // Tgas/(300 K) (#)
    double invT    = 1.0 / Tgas;                    // inverse of T (1/K)
    double invTe   = 1.0 / Te;                      // inverse of T (1/eV)
    double sqrTgas = sqrt(Tgas);                    // Tgas rootsquare (K**0.5)

    // clang-format off
    {% for assign in ode.rateeqns -%}
        {{ assign | stmwrap(80, 8) }}
        {{ "" }}
    {% endfor %}

    {% for m in ode.ratemodifier -%}
        {{ m }};
    {% endfor %}
    // clang-format on

    return NAUNET_SUCCESS;
}

int EvalHeatingRates(double *kh, double *y, NaunetData *u_data) {
    // clang-format off
    {% for v in network.varis.keys() -%}
        double {{ v }} = u_data->{{ v }};
    {% endfor %}
    // clang-format on

    double Te      = Tgas * 8.617343e-5;            // Tgas in eV (eV)
    double lnTe    = log(Te);                       // ln of Te (#)
    double T32     = Tgas * 0.0033333333333333335;  // Tgas/(300 K) (#)
    double invT    = 1.0 / Tgas;                    // inverse of T (1/K)
    double invTe   = 1.0 / Te;                      // inverse of T (1/eV)
    double sqrTgas = sqrt(Tgas);                    // Tgas rootsquare (K**0.5)

    // clang-format off
    {% for assign in ode.hrateeqns -%}
        {{ assign | stmwrap(80, 8) }}
        {{ "" }}
    {% endfor %}

    // clang-format on

    return NAUNET_SUCCESS;
}

int EvalCoolingRates(double *kc, double *y, NaunetData *u_data) {
    // clang-format off
    {% for v in network.varis.keys() -%}
        double {{ v }} = u_data->{{ v }};
    {% endfor %}
    // clang-format on

    double Te      = Tgas * 8.617343e-5;            // Tgas in eV (eV)
    double lnTe    = log(Te);                       // ln of Te (#)
    double T32     = Tgas * 0.0033333333333333335;  // Tgas/(300 K) (#)
    double invT    = 1.0 / Tgas;                    // inverse of T (1/K)
    double invTe   = 1.0 / Te;                      // inverse of T (1/eV)
    double sqrTgas = sqrt(Tgas);                    // Tgas rootsquare (K**0.5)

    // clang-format off
    {% for assign in ode.crateeqns -%}
        {{ assign | stmwrap(80, 8) }}
        {{ "" }}
    {% endfor %}
    // clang-format on

    return NAUNET_SUCCESS;
};

Observer::Observer(int mxsteps) {
    mxsteps_ = mxsteps;
    step_    = 0;
    time_    = 0.0;
};

Observer::~Observer(){};

void Observer::operator()(const vector_type &x, double t) {
    step_ += 1;
    time_ = t;
    if (step_ > mxsteps_) {
        char err[70];
        sprintf(err, "mxstep steps taken before reaching tout. t=%13.7e",
                time_);
        throw std::runtime_error(err);
    }
};

Fex::Fex(NaunetData *data) {
    u_data  = new NaunetData();
    *u_data = *data;
};

Fex &Fex::operator=(const Fex &rhs) {
    if (this != &rhs) {
        *u_data = *rhs.u_data;
    }
    return *this;
}

Fex::Fex(const Fex &rhs) { u_data = new NaunetData(*(rhs.u_data)); };

Fex::~Fex() { delete u_data; };

void Fex::operator()(const vector_type &abund, vector_type &ydot, double t) {
    // clang-format off

    double y[NEQUATIONS] = {0.0};
    for (int i = 0; i < NEQUATIONS; i++) {
        y[i] = abund[i];
    }

    {% for v in network.varis.keys() -%}
        double {{ v }} = u_data->{{ v }};
    {% endfor %}

#if (NHEATPROCS || NCOOLPROCS)
    if (mu < 0) mu = GetMu(y);
    if (gamma < 0) gamma = GetGamma(y);
#endif

    {% for v in network.locvars -%}
        {{ v }};
    {% endfor %}

    // clang-format on

    double k[NREACTIONS] = {0.0};
    EvalRates(k, y, u_data);

#if NHEATPROCS
    double kh[NHEATPROCS] = {0.0};
    EvalHeatingRates(kh, y, u_data);
#endif

#if NCOOLPROCS
    double kc[NCOOLPROCS] = {0.0};
    EvalCoolingRates(kc, y, u_data);
#endif

    // clang-format off
    {% for eq in ode.fex -%}
        {{ eq | stmwrap(80, 8) }}
    {% endfor %}

    {% for m in ode.odemodifier -%}
        {{ m }};
    {% endfor %}
    // clang-format on
};

Jac::Jac(NaunetData *data) {
    u_data  = new NaunetData();
    *u_data = *data;
};

Jac &Jac::operator=(const Jac &rhs) {
    if (this != &rhs) {
        *u_data = *rhs.u_data;
    }
    return *this;
}

Jac::Jac(const Jac &rhs) { u_data = new NaunetData(*(rhs.u_data)); };

Jac::~Jac() { delete u_data; };

void Jac::operator()(const vector_type &abund, matrix_type &j, const double &t,
                     vector_type &dfdt) {
    // clang-format off

    double y[NEQUATIONS] = {0.0};
    for (int i = 0; i < NEQUATIONS; i++) {
        y[i] = abund[i];
    }

    {% for v in network.varis.keys() -%}
        double {{ v }} = u_data->{{ v }};
    {% endfor %}

#if (NHEATPROCS || NCOOLPROCS)
    if (mu < 0) mu = GetMu(y);
    if (gamma < 0) gamma = GetGamma(y);
#endif

    // clang-format on

    double k[NREACTIONS] = {0.0};
    EvalRates(k, y, u_data);

#if NHEATPROCS
    double kh[NHEATPROCS] = {0.0};
    EvalHeatingRates(kh, y, u_data);
#endif

#if NCOOLPROCS
    double kc[NCOOLPROCS] = {0.0};
    EvalCoolingRates(kc, y, u_data);
#endif

    j = boost::numeric::ublas::zero_matrix<double>(NEQUATIONS, NEQUATIONS);

    // clang-format off
    {% for eq in ode.jac -%}
        {{ eq | stmwrap(80, 8) }}
    {% endfor %}
    // clang-format on

    for (int i = 0; i < NEQUATIONS; i++) {
        dfdt[i] = 0.0;
    }
};
