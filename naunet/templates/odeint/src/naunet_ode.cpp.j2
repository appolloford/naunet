#include <math.h>
/* {% if ode.header %} */
#include "{{ ode.header }}"
/* {% else %} */
#include <boost/numeric/odeint.hpp>

#include "naunet_data.h"
/* {% endif %} */
#include "naunet_constants.h"
#include "naunet_macros.h"
#include "naunet_physics.h"

/* {% if ode.header %} */
/* {% else %} */
typedef boost::numeric::ublas::vector<double> vector_type;
typedef boost::numeric::ublas::matrix<double> matrix_type;
/* {% endif %} */

/* {% set wrap = "\n        " -%} */
/* {% set bclose = wrap + "}" -%} */

using namespace boost::numeric::odeint;

int EvalRates(double *k, double *y, NaunetData *u_data) {
    // clang-format off
    {% for v in variables.varis -%}
        double {{ v }} = u_data->{{ v }};
    {% endfor %}
    // clang-format on

    double Te      = Tgas * 8.617343e-5;            // Tgas in eV (eV)
    double lnTe    = log(Te);                       // ln of Te (#)
    double T32     = Tgas * 0.0033333333333333335;  // Tgas/(300 K) (#)
    double invT    = 1.0 / Tgas;                    // inverse of T (1/K)
    double invTe   = 1.0 / Te;                      // inverse of T (1/eV)
    double sqrTgas = sqrt(Tgas);                    // Tgas rootsquare (K**0.5)

    // clang-format off
    {% for assign in ode.rateeqns -%}
        {{ assign | stmwrap(80, 8) }}
        {{ "" }}
    {% endfor %}

    {% for m in ode.ratemodifier -%}
        {{ m }};
    {% endfor %}
    // clang-format on

    return NAUNET_SUCCESS;
}

Fex::Fex(NaunetData *data) {
    u_data  = new NaunetData();
    *u_data = *data;
};

Fex::~Fex(){
    // delete u_data;
};

void Fex::operator()(const vector_type &abund, vector_type &ydot, double t) {
    // clang-format off

    double k[NREACTIONS]  = {0.0};
    double y[NEQUATIONS] = {0.0};
    for (int i = 0; i < NEQUATIONS; i++) {
        y[i] = abund[i];
    }

    {% for v in variables.varis -%}
        double {{ v }} = u_data->{{ v }};
    {% endfor %}

    {% for v in variables.tvaris -%}
        double {{ v }} = u_data->{{ v }};
    {% endfor %}

    {% if variables.tvaris -%}
    if (mu < 0) mu = GetMu(y);
    if (gamma < 0) gamma = GetGamma(y);
    {% endif -%}

    {% for v in variables.user_var -%}
        {{ v }};
    {% endfor %}  // clang-format on

    EvalRates(k, y, u_data);

    // clang-format off
    {% for eq in ode.fex -%}
        {{ eq | stmwrap(80, 8) }}
    {% endfor %}

    {% for m in ode.odemodifier -%}
        {{ m }};
    {% endfor %}
    // clang-format on
};

Jac::Jac(NaunetData *data) {
    u_data  = new NaunetData();
    *u_data = *data;
};

Jac::~Jac(){
    // delete u_data;
};

void Jac::operator()(const vector_type &abund, matrix_type &j, const double &t,
                     vector_type &dfdt) {
    // clang-format off

    double k[NREACTIONS]  = {0.0};
    double y[NEQUATIONS] = {0.0};
    for (int i = 0; i < NEQUATIONS; i++) {
        y[i] = abund[i];
    }

    {% for v in variables.varis -%}
        double {{ v }} = u_data->{{ v }};
    {% endfor %}

    {% for v in variables.tvaris -%}
        double {{ v }} = u_data->{{ v }};
    {% endfor %}

    {% if variables.tvaris -%}
    if (mu < 0) mu = GetMu(y);
    if (gamma < 0) gamma = GetGamma(y);
    {% endif -%}

    // clang-format on

    EvalRates(k, y, u_data);

    // clang-format off
    {% for eq in ode.jac -%}
        {{ eq | stmwrap(80, 8) }}
    {% endfor %}
    // clang-format on

    for (int i = 0; i < NEQUATIONS; i++) {
        dfdt[i] = 0.0;
    }
};
