{% if header %}
#include "{{ header }}"
{% else %}
#include "naunet_data.h"
{% endif %}
#include "naunet_ode.h"
#include "naunet_macros.h"

using namespace boost::numeric::odeint;


Naunet::Naunet() : m_atol(1e-20),
                   m_rtol(1e-5)
{
};

Naunet::~Naunet()
{
};

int Naunet::initSolver()
{
    return NAUNET_SUCCESS;
};

int Naunet::solve(double *ab, double dt, NaunetData *data)
{
    vector_type y(NSPECIES);
    for (int i=0; i<NSPECIES; i++)
    {
        y[i] = ab[i];
    }

    // TODO: test the two methods from odeint stiff system example
    // size_t num_of_steps = integrate_const(
    //     make_dense_output<rosenbrock4<double>>(m_atol, m_rtol),
    //     make_pair(fex(data), jac(data)), y, 0.0, dt, dt
    // );

    // size_t num_of_steps = integrate_const(
    //     make_dense_output<runge_kutta_dopri5<vector_type>>(m_atol, m_rtol),
    //     fex(data), y, 0.0, dt, dt
    // );

    size_t num_of_steps = integrate_adaptive(
        make_controlled<rosenbrock4<double>>(m_atol, m_rtol),
        std::make_pair(fex(data), jac(data)), y, 0.0, dt, dt
    );

    for (int i=0; i<NSPECIES; i++)
    {
        ab[i] = y[i];
    }

    return NAUNET_SUCCESS;
};

#ifdef PYMODULE
py::array_t<double> Naunet::wrapper_solve(py::array_t<double> arr, double dt, NaunetData *data)
{
    py::buffer_info info = arr.request();
    double *ab = static_cast<double *>(info.ptr);

    solve(ab, dt, data);

    return py::array_t<double>(info.shape, ab);

}
#endif
