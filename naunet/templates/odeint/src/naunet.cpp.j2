/* {% if header %} */
#include "{{ header }}"
/* {% else %} */
#include "naunet_data.h"
/* {% endif %} */
#include "naunet_macros.h"
#include "naunet_ode.h"

using namespace boost::numeric::odeint;

Naunet::Naunet(){};

Naunet::~Naunet(){};

int Naunet::Init(int nsystem, double atol, double rtol) {
    if (nsystem != 1) {
        printf("This solver doesn't support nsystem > 1!");
        return NAUNET_FAIL;
    }

    n_system_ = nsystem;
    atol_     = atol;
    rtol_     = rtol;
    return NAUNET_SUCCESS;
};

int Naunet::Finalize() { return NAUNET_SUCCESS; }

int Naunet::Solve(double *abund, double dt, NaunetData *data) {
    vector_type y(NSPECIES);
    for (int i = 0; i < NSPECIES; i++) {
        y[i] = abund[i];
    }

    // TODO: test the two methods from odeint stiff system example
    // size_t num_of_steps = integrate_const(
    //     make_dense_output<rosenbrock4<double>>(atol_, rtol_),
    //     make_pair(fex(data), jac(data)), y, 0.0, dt, dt
    // );

    // size_t num_of_steps = integrate_const(
    //     make_dense_output<runge_kutta_dopri5<vector_type>>(atol_, rtol_),
    //     fex(data), y, 0.0, dt, dt
    // );

    size_t num_of_steps = integrate_adaptive(
        make_controlled<rosenbrock4<double>>(atol_, rtol_),
        std::make_pair(Fex(data), Jac(data)), y, 0.0, dt, dt);

    for (int i = 0; i < NSPECIES; i++) {
        abund[i] = y[i];
    }

    return NAUNET_SUCCESS;
};

#ifdef PYMODULE
py::array_t<double> Naunet::PyWrapSolve(py::array_t<double> arr, double dt,
                                        NaunetData *data) {
    py::buffer_info info = arr.request();
    double *abund        = static_cast<double *>(info.ptr);

    Solve(abund, dt, data);

    return py::array_t<double>(info.shape, abund);
}
#endif
