#include <cvode/cvode.h>  // prototypes for CVODE fcts., consts.
/* {% if info.method == "dense" -%} */
#include <nvector/nvector_serial.h>     // access to serial N_Vector
#include <sundials/sundials_dense.h>    // use generic dense solver in precond
#include <sunlinsol/sunlinsol_dense.h>  // access to dense SUNLinearSolver
#include <sunmatrix/sunmatrix_dense.h>  // access to dense SUNMatrix
/* {% elif info.method == "sparse" -%} */
#include <nvector/nvector_serial.h>      // access to serial N_Vector
#include <sunlinsol/sunlinsol_klu.h>     // access to KLU sparse direct solver
#include <sunmatrix/sunmatrix_sparse.h>  // access to sparse SUNMatrix
/* {% elif info.method == "cusparse" -%} */
#include <nvector/nvector_cuda.h>
#include <sunlinsol/sunlinsol_cusolversp_batchqr.h>
#include <sunmatrix/sunmatrix_cusparse.h>
/* {% elif info.method == "spgmr" -%} */
#include <cvode/cvode_spils.h>          // access to CVSpils interface
#include <sunlinsol/sunlinsol_spgmr.h>  // access to SPGMR SUNLinearSolver
/* {% endif -%} */
/* {% if header %} */
#include "{{ header }}"
/* {% else %} */
#include <sundials/sundials_linearsolver.h>
#include <sundials/sundials_math.h>   // contains the macros ABS, SUNSQR, EXP
#include <sundials/sundials_types.h>  // defs. of realtype, sunindextype

#include "naunet_data.h"
/* {% endif %} */
#include "naunet_ode.h"

// check_flag function is from the cvDiurnals_ky.c example from the CVODE
// package. Check function return value...
//   opt == 0 means SUNDIALS function allocates memory so check if
//            returned NULL pointer
//   opt == 1 means SUNDIALS function returns a flag so check if
//            flag >= 0
//   opt == 2 means function allocates memory so check if returned
//            NULL pointer
static int check_flag(void *flagvalue, const char *funcname, int opt) {
    int *errflag;

    /* Check if SUNDIALS function returned NULL pointer - no memory allocated */
    if (opt == 0 && flagvalue == NULL) {
        fprintf(stderr,
                "\nSUNDIALS_ERROR: %s() failed - returned NULL pointer\n\n",
                funcname);
        return 1;
    }

    /* Check if flag < 0 */
    else if (opt == 1) {
        errflag = (int *)flagvalue;
        if (*errflag < 0) {
            fprintf(stderr, "\nSUNDIALS_ERROR: %s() failed with flag = %d\n\n",
                    funcname, *errflag);
            return 1;
        }
    }

    /* Check if function returned NULL pointer - no memory allocated */
    else if (opt == 2 && flagvalue == NULL) {
        fprintf(stderr,
                "\nMEMORY_ERROR: %s() failed - returned NULL pointer\n\n",
                funcname);
        return 1;
    }

    return 0;
}

Naunet::Naunet(){};

Naunet::~Naunet(){};

int Naunet::Init(int nsystem, double atol, double rtol, int mxsteps) {
    n_system_ = nsystem;
    mxsteps_  = mxsteps;
    atol_     = atol;
    rtol_     = rtol;

    /* {% if info.method == "dense" -%} */
    if (nsystem != 1) {
        printf("This solver doesn't support nsystem > 1!");
        return NAUNET_FAIL;
    }

    cv_y_  = N_VNew_Serial((sunindextype)NEQUATIONS);
    cv_a_  = SUNDenseMatrix(NEQUATIONS, NEQUATIONS);
    cv_ls_ = SUNLinSol_Dense(cv_y_, cv_a_);

    cv_mem_ = CVodeCreate(CV_BDF);

    int flag;

    flag = CVodeInit(cv_mem_, Fex, 0.0, cv_y_);
    if (check_flag(&flag, "CVodeInit", 1)) return 1;
    flag = CVodeSetMaxNumSteps(cv_mem_, mxsteps_);
    if (check_flag(&flag, "CVodeSetMaxNumSteps", 0)) return 1;
    flag = CVodeSStolerances(cv_mem_, rtol_, atol_);
    if (check_flag(&flag, "CVodeSStolerances", 1)) return 1;
    flag = CVodeSetLinearSolver(cv_mem_, cv_ls_, cv_a_);
    if (check_flag(&flag, "CVodeSetLinearSolver", 1)) return 1;
    flag = CVodeSetJacFn(cv_mem_, Jac);
    if (check_flag(&flag, "CVodeSetJacFn", 1)) return 1;

    /* {% elif info.method == "sparse" -%} */
    if (nsystem != 1) {
        printf("This solver doesn't support nsystem > 1!");
        return NAUNET_FAIL;
    }

    cv_y_  = N_VNew_Serial((sunindextype)NEQUATIONS);
    cv_a_  = SUNSparseMatrix(NEQUATIONS, NEQUATIONS, NNZ, CSR_MAT);
    cv_ls_ = SUNLinSol_KLU(cv_y_, cv_a_);

    cv_mem_ = CVodeCreate(CV_BDF);

    int flag;

    flag = CVodeInit(cv_mem_, Fex, 0.0, cv_y_);
    if (check_flag(&flag, "CVodeInit", 1)) return 1;
    flag = CVodeSetMaxNumSteps(cv_mem_, mxsteps_);
    if (check_flag(&flag, "CVodeSetMaxNumSteps", 0)) return 1;
    flag = CVodeSStolerances(cv_mem_, rtol_, atol_);
    if (check_flag(&flag, "CVodeSStolerances", 1)) return 1;
    flag = CVodeSetLinearSolver(cv_mem_, cv_ls_, cv_a_);
    if (check_flag(&flag, "CVodeSetLinearSolver", 1)) return 1;
    flag = CVodeSetJacFn(cv_mem_, Jac);
    if (check_flag(&flag, "CVodeSetJacFn", 1)) return 1;

    /* {% elif info.method == "cusparse" -%} */

    // if (nsystem < NSTREAMS ||  nsystem % NSTREAMS != 0) {
    //     printf("Invalid size of system!");
    //     return NAUNET_FAIL;
    // }

    cudaMallocHost((void **)&h_ab, sizeof(realtype) * n_system_ * NEQUATIONS);
    cudaMallocHost((void **)&h_data, sizeof(NaunetData) * n_system_);

    n_stream_in_use_ = nsystem / NSTREAMS >= 32 ? NSTREAMS : 1;

    cudaError_t cuerr;
    int flag;

    for (int i = 0; i < n_stream_in_use_; i++) {

        cuerr = cudaStreamCreate(&custream_[i]);
        // SUNCudaThreadDirectExecPolicy stream_exec_policy(nsystem / n_stream_in_use_, custream_[i]);
        // SUNCudaBlockReduceExecPolicy reduce_exec_policy(nsystem / n_stream_in_use_, 0, custream_[i]);
        stream_exec_policy_[i] = new SUNCudaThreadDirectExecPolicy(nsystem / n_stream_in_use_, custream_[i]);
        reduce_exec_policy_[i] = new SUNCudaBlockReduceExecPolicy(nsystem / n_stream_in_use_, 0, custream_[i]);

        cusparseCreate(&cusp_handle_[i]);
        cusparseSetStream(cusp_handle_[i], custream_[i]);
        cusolverSpCreate(&cusol_handle_[i]);
        cusolverSpSetStream(cusol_handle_[i], custream_[i]);
        cv_y_[i]  = N_VNew_Cuda(NEQUATIONS * nsystem / n_stream_in_use_);
        flag = N_VSetKernelExecPolicy_Cuda(cv_y_[i], stream_exec_policy_[i], reduce_exec_policy_[i]);
        if (check_flag(&flag, "N_VSetKernelExecPolicy_Cuda", 0)) return 1;
        cv_a_[i]  = SUNMatrix_cuSparse_NewBlockCSR(nsystem / n_stream_in_use_, NEQUATIONS, NEQUATIONS,
                                                NNZ, cusp_handle_[i]);
        cv_ls_[i] = SUNLinSol_cuSolverSp_batchQR(cv_y_[i], cv_a_[i], cusol_handle_[i]);
        // abstol = N_VNew_Cuda(neq);
        SUNMatrix_cuSparse_SetFixedPattern(cv_a_[i], 1);
        InitJac(cv_a_[i]);

        cv_mem_[i] = CVodeCreate(CV_BDF);

        flag = CVodeInit(cv_mem_[i], Fex, 0.0, cv_y_[i]);
        if (check_flag(&flag, "CVodeInit", 1)) return 1;
        flag = CVodeSetMaxNumSteps(cv_mem_[i], mxsteps_);
        if (check_flag(&flag, "CVodeSetMaxNumSteps", 0)) return 1;
        flag = CVodeSStolerances(cv_mem_[i], rtol_, atol_);
        if (check_flag(&flag, "CVodeSStolerances", 1)) return 1;
        flag = CVodeSetLinearSolver(cv_mem_[i], cv_ls_[i], cv_a_[i]);
        if (check_flag(&flag, "CVodeSetLinearSolver", 1)) return 1;
        flag = CVodeSetJacFn(cv_mem_[i], Jac);
        if (check_flag(&flag, "CVodeSetJacFn", 1)) return 1;

    }

    /* {% elif info.method == "spgmr" -%} */
    // TODO: Try GMRES solvers
    // cv_ls_ = SUNLinSol_SPGMR(cv_y_, 0, 0);
    // if (check_flag((void *)cv_ls_, "SUNLinSol_SPGMR", 0)) return 1;
    // flag = CVSpilsSetLinearSolver(cv_mem_, cv_ls_);
    // if (check_flag(&flag, "CVSpilsSetLinearSolver", 1)) return 1;
    // flag = CVSpilsSetJacTimes(cv_mem_, NULL, Jtv);
    // if (check_flag(&flag, "CVSpilsSetJacTimes", 1)) return 1;

    /* {% endif %} */

    // reset the n_vector to empty, maybe not necessary
    /* {% if info.method == "dense" or info.method == "sparse" -%} */

    // N_VDestroy(cv_y_);
    // cv_y_ = N_VNewEmpty_Serial((sunindextype)NEQUATIONS);

    /* {% elif info.method == "cusparse" -%} */

    // N_VDestroy(cv_y_);
    // cv_y_ = N_VNewEmpty_Cuda();

    /* {% endif -%} */

    return NAUNET_SUCCESS;
};

int Naunet::DebugInfo() {
    long int nst, nfe, nsetups, nje, netf, nge, nni, ncfn;
    int flag;

    /* {% if info.method == "dense" or info.method == "sparse" -%} */

    flag = CVodeGetNumSteps(cv_mem_, &nst);
    check_flag(&flag, "CVodeGetNumSteps", 1);
    flag = CVodeGetNumRhsEvals(cv_mem_, &nfe);
    check_flag(&flag, "CVodeGetNumRhsEvals", 1);
    flag = CVodeGetNumLinSolvSetups(cv_mem_, &nsetups);
    check_flag(&flag, "CVodeGetNumLinSolvSetups", 1);
    flag = CVodeGetNumErrTestFails(cv_mem_, &netf);
    check_flag(&flag, "CVodeGetNumErrTestFails", 1);
    flag = CVodeGetNumNonlinSolvIters(cv_mem_, &nni);
    check_flag(&flag, "CVodeGetNumNonlinSolvIters", 1);
    flag = CVodeGetNumNonlinSolvConvFails(cv_mem_, &ncfn);
    check_flag(&flag, "CVodeGetNumNonlinSolvConvFails", 1);

    flag = CVodeGetNumJacEvals(cv_mem_, &nje);
    check_flag(&flag, "CVodeGetNumJacEvals", 1);

    flag = CVodeGetNumGEvals(cv_mem_, &nge);
    check_flag(&flag, "CVodeGetNumGEvals", 1);

    printf("\nFinal Statistics:\n");
    printf("nst = %-6ld nfe  = %-6ld nsetups = %-6ld nje = %ld\n", nst, nfe, nsetups, nje);
    printf("nni = %-6ld ncfn = %-6ld netf = %-6ld    nge = %ld\n \n", nni, ncfn, netf, nge);

    /* {% elif info.method == "cusparse" %} */

    size_t cuSpInternalSize, cuSpWorkSize;

    for (int i=0; i<n_stream_in_use_; i++) {

        flag = CVodeGetNumSteps(cv_mem_[i], &nst);
        check_flag(&flag, "CVodeGetNumSteps", 1);
        flag = CVodeGetNumRhsEvals(cv_mem_[i], &nfe);
        check_flag(&flag, "CVodeGetNumRhsEvals", 1);
        flag = CVodeGetNumLinSolvSetups(cv_mem_[i], &nsetups);
        check_flag(&flag, "CVodeGetNumLinSolvSetups", 1);
        flag = CVodeGetNumErrTestFails(cv_mem_[i], &netf);
        check_flag(&flag, "CVodeGetNumErrTestFails", 1);
        flag = CVodeGetNumNonlinSolvIters(cv_mem_[i], &nni);
        check_flag(&flag, "CVodeGetNumNonlinSolvIters", 1);
        flag = CVodeGetNumNonlinSolvConvFails(cv_mem_[i], &ncfn);
        check_flag(&flag, "CVodeGetNumNonlinSolvConvFails", 1);

        flag = CVodeGetNumJacEvals(cv_mem_[i], &nje);
        check_flag(&flag, "CVodeGetNumJacEvals", 1);

        flag = CVodeGetNumGEvals(cv_mem_[i], &nge);
        check_flag(&flag, "CVodeGetNumGEvals", 1);

        SUNLinSol_cuSolverSp_batchQR_GetDeviceSpace(cv_ls_[i], &cuSpInternalSize, &cuSpWorkSize);

        printf("\nFinal Statistics of %d stream:\n", i);
        printf("nst = %-6ld nfe  = %-6ld nsetups = %-6ld nje = %ld\n", nst, nfe, nsetups, nje);
        printf("nni = %-6ld ncfn = %-6ld netf = %-6ld    nge = %ld\n \n", nni, ncfn, netf, nge);
        printf("cuSolverSp numerical factorization workspace size (in bytes) = %ld\n", cuSpWorkSize);
        printf("cuSolverSp internal Q, R buffer size (in bytes) = %ld\n", cuSpInternalSize);
    }
    /* {% endif %} */

    return NAUNET_SUCCESS;
}

int Naunet::Finalize() {

    /* {% if info.method == "dense" or info.method == "sparse" -%} */

    // N_VDestroy(cv_y_);
    N_VFreeEmpty(cv_y_);
    SUNMatDestroy(cv_a_);
    CVodeFree(&cv_mem_);
    SUNLinSolFree(cv_ls_);
    // delete m_data;

    /* {% elif info.method == "cusparse" -%} */
    for (int i = 0; i < n_stream_in_use_; i++) {
        N_VFreeEmpty(cv_y_[i]);
        SUNMatDestroy(cv_a_[i]);
        CVodeFree(&cv_mem_[i]);
        SUNLinSolFree(cv_ls_[i]);

        cusparseDestroy(cusp_handle_[i]);
        cusolverSpDestroy(cusol_handle_[i]);
        cudaStreamDestroy(custream_[i]);
    }

    cudaFreeHost(h_ab);
    cudaFreeHost(h_data);

    /* {% endif %} */

    return NAUNET_SUCCESS;
};

/* {% if info.method == "cusparse" %} */
// To reset the size of cusparse solver
int Naunet::Reset(int nsystem, double atol, double rtol, int mxsteps) {

    // if (nsystem < NSTREAMS ||  nsystem % NSTREAMS != 0) {
    //     printf("Invalid size of system!");
    //     return NAUNET_FAIL;
    // }

    n_stream_in_use_ = nsystem / NSTREAMS >= 32 ? NSTREAMS : 1;

    n_system_ = nsystem;
    mxsteps_  = mxsteps;
    atol_     = atol;
    rtol_     = rtol;

    cudaFreeHost(h_ab);
    cudaFreeHost(h_data);

    cudaMallocHost((void **)&h_ab, sizeof(realtype) * n_system_ * NEQUATIONS);
    cudaMallocHost((void **)&h_data, sizeof(NaunetData) * n_system_);

    int flag;

    for (int i = 0; i < n_stream_in_use_; i++) {
        N_VDestroy(cv_y_[i]);
        SUNMatDestroy(cv_a_[i]);
        SUNLinSolFree(cv_ls_[i]);
        CVodeFree(&cv_mem_[i]);

        // SUNCudaThreadDirectExecPolicy stream_exec_policy(nsystem / n_stream_in_use_, custream_[i]);
        // SUNCudaBlockReduceExecPolicy reduce_exec_policy(nsystem / n_stream_in_use_, 0, custream_[i]);

        cv_y_[i] = N_VNew_Cuda(NEQUATIONS * nsystem / n_stream_in_use_);
        flag = N_VSetKernelExecPolicy_Cuda(cv_y_[i], stream_exec_policy_[i], reduce_exec_policy_[i]);
        if (check_flag(&flag, "N_VSetKernelExecPolicy_Cuda", 0)) return 1;
        cv_a_[i] = SUNMatrix_cuSparse_NewBlockCSR(nsystem / n_stream_in_use_, NEQUATIONS, NEQUATIONS, NNZ,
                                                  cusp_handle_[i]);
        cv_ls_[i] = SUNLinSol_cuSolverSp_batchQR(cv_y_[i], cv_a_[i], cusol_handle_[i]);
        SUNMatrix_cuSparse_SetFixedPattern(cv_a_[i], 1);
        InitJac(cv_a_[i]);

        cv_mem_[i] = CVodeCreate(CV_BDF);

        flag = CVodeInit(cv_mem_[i], Fex, 0.0, cv_y_[i]);
        if (check_flag(&flag, "CVodeInit", 1)) return 1;
        flag = CVodeSetMaxNumSteps(cv_mem_[i], mxsteps_);
        if (check_flag(&flag, "CVodeSetMaxNumSteps", 0)) return 1;
        flag = CVodeSStolerances(cv_mem_[i], rtol_, atol_);
        if (check_flag(&flag, "CVodeSStolerances", 1)) return 1;
        flag = CVodeSetLinearSolver(cv_mem_[i], cv_ls_[i], cv_a_[i]);
        if (check_flag(&flag, "CVodeSetLinearSolver", 1)) return 1;
        flag = CVodeSetJacFn(cv_mem_[i], Jac);
        if (check_flag(&flag, "CVodeSetJacFn", 1)) return 1;

        // reset the n_vector to empty, maybe not necessary
        // N_VDestroy(cv_y_);
        // cv_y_ = N_VNewEmpty_Cuda();
    }

    return NAUNET_SUCCESS;
};
/* {% endif %} */

int Naunet::Solve(realtype *ab, realtype dt, NaunetData *data) {

    int flag;

    /* {% if info.method == "dense" or info.method == "sparse" -%} */

    // realtype *ydata = N_VGetArrayPointer(cv_y_);
    // for (int i=0; i<NEQUATIONS; i++)
    // {
    //     ydata[i] = ab[i];
    // }
    N_VSetArrayPointer(ab, cv_y_);

    flag = CVodeReInit(cv_mem_, 0.0, cv_y_);
    if (check_flag(&flag, "CVodeReInit", 1)) return 1;
    flag = CVodeSetUserData(cv_mem_, data);
    if (check_flag(&flag, "CVodeSetUserData", 1)) return 1;

    realtype t0 = 0.0;
    flag = CVode(cv_mem_, dt, cv_y_, &t0, CV_NORMAL);

    ab   = N_VGetArrayPointer(cv_y_);

    /* {% elif info.method == "cusparse" -%} */

    for (int i = 0; i < n_system_ ; i++)
    {
        h_data[i] = data[i];
        for (int j = 0; j < NEQUATIONS; j++) {
            int idx = i * NEQUATIONS + j;
            h_ab[idx] = ab[idx];
        }
    }

    for (int i = 0; i < n_stream_in_use_; i++) {
        realtype t0 = 0.0;

        // ! Bug: I don't know why n_vector does not save the stream_exec_policy and reduce_exec_policy
        N_VSetKernelExecPolicy_Cuda(cv_y_[i], stream_exec_policy_[i], reduce_exec_policy_[i]);

        // This way is too slow
        // realtype *ydata = N_VGetArrayPointer(cv_y_[i]);
        // for (int i = 0; i < NEQUATIONS; i++)
        // {
        //     ydata[i] = ab[i];
        // }
        N_VSetHostArrayPointer_Cuda(h_ab + i * n_system_ * NEQUATIONS / n_stream_in_use_, cv_y_[i]);
        N_VCopyToDevice_Cuda(cv_y_[i]);

#ifdef NAUNET_DEBUG
        // sunindextype lrw, liw;
        // N_VSpace_Cuda(cv_y_[i], &lrw, &liw);
        // printf("NVector space: real-%d, int-%d\n", lrw, liw);
#endif

        flag = CVodeReInit(cv_mem_[i], 0.0, cv_y_[i]);
        if (check_flag(&flag, "CVodeReInit", 1)) return 1;
        flag = CVodeSetUserData(cv_mem_[i], h_data + i * n_system_ / n_stream_in_use_);
        if (check_flag(&flag, "CVodeSetUserData", 1)) return 1;

        flag = CVode(cv_mem_[i], dt, cv_y_[i], &t0, CV_NORMAL);

        N_VCopyFromDevice_Cuda(cv_y_[i]);
        realtype *local_ab = N_VGetHostArrayPointer_Cuda(cv_y_[i]);
        for (int idx = 0; idx < n_system_ * NEQUATIONS / n_stream_in_use_; idx++)
        {
            ab[idx + i * n_system_ * NEQUATIONS / n_stream_in_use_] = local_ab[idx];
        }

    }

    cudaDeviceSynchronize();

    /* {% endif -%} */

    return NAUNET_SUCCESS;
};

#ifdef PYMODULE
py::array_t<realtype> Naunet::PyWrapSolve(py::array_t<realtype> arr,
                                          realtype dt, NaunetData *data) {
    py::buffer_info info = arr.request();
    realtype *ab         = static_cast<realtype *>(info.ptr);

    Solve(ab, dt, data);

    return py::array_t<realtype>(info.shape, ab);
}
#endif
