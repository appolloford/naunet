{% if ode.header %}
#include "{{ ode.header }}"
{% else %}
#include <math.h>
#include <cvode/cvode.h>
{% if info.method == "dense" -%}
#include <nvector/nvector_serial.h>
#include <sunmatrix/sunmatrix_dense.h> // access to dense SUNMatrix
{% elif info.method == "sparse" -%}
#include <nvector/nvector_serial.h>
#include <sunmatrix/sunmatrix_sparse.h> // access to sparse SUNMatrix
{% elif info.method == "cusparse" -%}
#include <nvector/nvector_cuda.h>
#include <sunmatrix/sunmatrix_cusparse.h>
{% endif -%}
#include <sundials/sundials_types.h>   // defs. of realtype, sunindextype
#include "naunet_macros.h"
#include "naunet_userdata.h"
{% endif %}

{% if info.device == "gpu" -%}
__device__ __host__
{% endif -%}
int calculate_rates(realtype *k, realtype *y, UserData *u_data)
{

    {% for v in ode.var -%}
        {{ v }}
    {% endfor %}

    realtype Te = Tgas*8.617343e-5; //Tgas in eV (eV)
    realtype lnTe = log(Te); //ln of Te (#)
    realtype T32 = Tgas*0.0033333333333333335; //Tgas/(300 K) (#)
    realtype invT = 1.0/Tgas; //inverse of T (1/K)
    realtype invTe = 1.0/Te; //inverse of T (1/eV)
    realtype sqrTgas = sqrt(Tgas); //Tgas rootsquare (K**0.5)

    {% set wrap = "\n        " -%}
    {% set bclose = wrap + "}" -%}
    {% for assign in ode.rateeqns -%}
        {{ assign | wordwrap(80) | replace("\n", wrap) | replace(bclose, '\n    }') }}
        {{ "" }}
    {% endfor %}

    return NAUNET_SUCCESS;
}

int fex(realtype t, N_Vector u, N_Vector u_dot, void *user_data) 
{

{% if info.method == "dense" or info.method == "sparse"%}
    realtype *y      = N_VGetArrayPointer(u);
    realtype *ydot   = N_VGetArrayPointer(u_dot);
    UserData *u_data = (UserData*) user_data;
    {% for v in ode.var -%}
        {{ v }}
    {% endfor %}

    realtype k[NREACTIONS] = {0.0};
    calculate_rates(k, y, u_data);

    {% for eq in ode.fex -%}
        {{ eq | wordwrap(80) | replace('\n', wrap) }}
    {% endfor %}

{% elif info.method == "cusparse" %}

    realtype *y     = N_VGetDeviceArrayPointer_Cuda(u);
    realtype *ydot  = N_VGetDeviceArrayPointer_Cuda(u_dot);
    UserData *h_udata = (UserData*) user_data;
    UserData *d_udata;

    cudaMalloc((void**)&d_udata, sizeof(UserData) * MAXNGROUPS);
    cudaMemcpy(d_udata, h_udata, sizeof(UserData) * MAXNGROUPS, cudaMemcpyHostToDevice);
    cudaDeviceSynchronize();
    
    unsigned block_size = BLOCKSIZE;
    unsigned grid_size = 1;
    f_kernel<<<grid_size, block_size>>>(y, ydot, d_udata);

    cudaDeviceSynchronize();
    cudaError_t cuerr = cudaGetLastError();
    if (cuerr != cudaSuccess) {
        fprintf(stderr,
            ">>> ERROR in Jac: cudaGetLastError returned %s\n",
            cudaGetErrorName(cuerr));
        return -1;
    }

{% endif %}

    return CV_SUCCESS;

}


{% if info.method != "cusparse" %}
int jtv(N_Vector v, N_Vector Jv, realtype t, N_Vector u, N_Vector fu, 
        void *user_data, N_Vector tmp) 
{
    realtype *x      = N_VGetArrayPointer(u);
    realtype *y      = N_VGetArrayPointer(v);
    realtype *ydot   = N_VGetArrayPointer(Jv);
    realtype *fx     = N_VGetArrayPointer(fu);

    UserData *u_data = (UserData*) user_data;
    {% for v in ode.var -%}
        {{ v }}
    {% endfor %}

    realtype k[NREACTIONS] = {0.0};
    calculate_rates(k, y, u_data);

    {% for eq in ode.fex -%}
        {{ eq | wordwrap(80) | replace('\n', wrap) }}
    {% endfor %}

    for (int i=0; i<NSPECIES; i++) {
        fx[i] = 0.0;
    }

    return CV_SUCCESS;

}
{% endif %}

int jac(realtype t, N_Vector u, N_Vector fu, SUNMatrix Jac, 
        void *user_data, N_Vector tmp1, N_Vector tmp2, N_Vector tmp3)
{
{% if info.method == "dense" %}
    realtype *y = N_VGetArrayPointer(u);
    UserData *u_data = (UserData*) user_data;
    {% for v in ode.var -%}
        {{ v }}
    {% endfor %}

    realtype k[NREACTIONS] = {0.0};
    calculate_rates(k, y, u_data);

    {% for eq in ode.jac -%}
        {{ eq | wordwrap(80) | replace('\n', wrap) }}
    {% endfor %}

{% elif info.method == "sparse" %}
    realtype *y = N_VGetArrayPointer(u);;
    sunindextype *rowptrs = SUNSparseMatrix_IndexPointers(Jac);
    sunindextype *colvals = SUNSparseMatrix_IndexValues(Jac);
    realtype *data = SUNSparseMatrix_Data(Jac);
    UserData *u_data = (UserData*) user_data;

    realtype k[NREACTIONS] = {0.0};
    calculate_rates(k, y, u_data);

    {% for rptr in ode.spjacrptr -%}
        {{ rptr }}
    {% endfor %}

    {% for cval in ode.spjaccval -%}
        {{ cval }}
    {% endfor %}

    {% for data in ode.spjacdata -%}
        {{ data }}
    {% endfor %}

{% elif info.method == "cusparse" %}
    realtype *y       = N_VGetDeviceArrayPointer_Cuda(u);
    realtype *data    = SUNMatrix_cuSparse_Data(Jac);
    UserData *h_udata = (UserData*) user_data;
    UserData *d_udata;

    cudaMalloc((void**)&d_udata, sizeof(UserData) * MAXNGROUPS);
    cudaMemcpy(d_udata, h_udata, sizeof(UserData) * MAXNGROUPS, cudaMemcpyHostToDevice);
    cudaDeviceSynchronize();
    
    unsigned block_size = BLOCKSIZE;
    unsigned grid_size = 1;
    j_kernel<<<grid_size, block_size>>>(y, data, d_udata);

    cudaDeviceSynchronize();
    cudaError_t cuerr = cudaGetLastError();
    if (cuerr != cudaSuccess) {
        fprintf(stderr,
            ">>> ERROR in Jac: cudaGetLastError returned %s\n",
            cudaGetErrorName(cuerr));
        return -1;
    }

{% endif %}

    return CV_SUCCESS;

}

{% if info.method == "cusparse" -%}
int jacInit(SUNMatrix jmatrix)
{
    int rowptrs[NSPECIES+1], colvals[NNZ];

    /* Zero out the Jacobian */
    SUNMatZero(jmatrix); 

    {% for rptr in ode.spjacrptr -%}
        {{ rptr }}
    {% endfor %}

    {% for cval in ode.spjaccval -%}
        {{ cval }}
    {% endfor %}

    /* copy rowptrs, colvals to the device */
    SUNMatrix_cuSparse_CopyToDevice(jmatrix, NULL, rowptrs, colvals);
    cudaDeviceSynchronize();

    return CV_SUCCESS;
}

__global__ void f_kernel(realtype *y, realtype *ydot, UserData *d_udata)
{
    int tidx = blockIdx.x*blockDim.x + threadIdx.x;
    int isys = tidx*NSPECIES;

    realtype yi[NSPECIES] = {0.0};
    realtype k[NREACTIONS] = {0.0};
    if ( tidx < MAXNGROUPS)
    {
        UserData *udata = &d_udata[tidx];
        for (int i=0; i<NSPECIES; i++)
        {
            yi[i] = y[isys + i];
        }
        calculate_rates(k, yi, udata);
    }

    {% for eq in ode.fex -%}
        {{ eq | replace("IDX", "isys + IDX") | wordwrap(80) | replace('\n', wrap) }}
    {% endfor %}

}

__global__ void j_kernel(realtype *y, realtype *data, UserData *d_udata)
{
    int tidx = blockIdx.x*blockDim.x + threadIdx.x;
    int gs   = blockDim.x * gridDim.x;
    int isys = tidx*NSPECIES;

    realtype yi[NSPECIES] = {0.0};
    realtype k[NREACTIONS] = {0.0};
    if ( tidx < MAXNGROUPS)
    {
        UserData *udata = &d_udata[tidx];
        for (int i=0; i<NSPECIES; i++)
        {
            yi[i] = y[isys + i];
        }
        calculate_rates(k, yi, udata);
    }

    {% for data in ode.spjacdata -%}
        {{ data | replace("data[", "data[isys + ") | replace("IDX", "isys + IDX")}}
    {% endfor %}

}

{% endif -%}
