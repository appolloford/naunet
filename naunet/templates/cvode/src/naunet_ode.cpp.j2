#include <math.h>
/* {% if info.method == "dense" -%} */
#include <nvector/nvector_serial.h>
#include <sunmatrix/sunmatrix_dense.h>  // access to dense SUNMatrix
/* {% elif info.method == "sparse" -%} */
#include <nvector/nvector_serial.h>
#include <sunmatrix/sunmatrix_sparse.h>  // access to sparse SUNMatrix
/* {% elif info.method == "cusparse" -%} */
#include <nvector/nvector_cuda.h>
#include <sunmatrix/sunmatrix_cusparse.h>
/* {% endif -%} */
/* {% if ode.header %} */
#include "{{ ode.header }}"
/* {% else %} */
#include <sundials/sundials_types.h>  // defs. of realtype, sunindextype

#include "naunet_data.h"
/* {% endif %} */
#include "naunet_constants.h"
#include "naunet_macros.h"
#include "naunet_physics.h"

#define IJth(A, i, j) SM_ELEMENT_D(A, i, j)

// clang-format off
{% if info.device == "gpu" -%} __device__ {% endif -%}
int EvalRates(realtype *k, realtype *y, NaunetData *u_data) {

    {% for v in variables.varis -%}
        realtype {{ v }} = u_data->{{ v }};
    {% endfor %}

    {% for v in variables.user_var -%}
        {{ v }};
    {% endfor %}

    // clang-format on

    // Some variable definitions from krome
    realtype Te      = Tgas * 8.617343e-5;            // Tgas in eV (eV)
    realtype lnTe    = log(Te);                       // ln of Te (#)
    realtype T32     = Tgas * 0.0033333333333333335;  // Tgas/(300 K) (#)
    realtype invT    = 1.0 / Tgas;                    // inverse of T (1/K)
    realtype invTe   = 1.0 / Te;                      // inverse of T (1/eV)
    realtype sqrTgas = sqrt(Tgas);  // Tgas rootsquare (K**0.5)

    // reaaction rate (k) of each reaction
    // clang-format off
    {% for assign in ode.rateeqns -%}
        {{ assign | stmwrap(80, 8) }}
        {{ "" }}
    {% endfor %}

    {% for m in ode.ratemodifier -%}
        {{ m }};
    {% endfor %}
    // clang-format on

    return NAUNET_SUCCESS;
}

/* {% if info.method == "cusparse" -%} */
int InitJac(SUNMatrix jmatrix) {
    // Zero out the Jacobian
    SUNMatZero(jmatrix);

    // clang-format off
    // number of non-zero elements in each row
    int rowptrs[NEQUATIONS + 1] = { 
        {{ ode.spjacrptrarr | stmwrap(80, 8) }}
    };

    // the column index of non-zero elements
    int colvals[NNZ] = {
        {{ ode.spjaccvalarr | stmwrap(80, 8) }}
    };

    // clang-format on

    // copy rowptrs, colvals to the device
    SUNMatrix_cuSparse_CopyToDevice(jmatrix, NULL, rowptrs, colvals);
    cudaDeviceSynchronize();

    return NAUNET_SUCCESS;
}

__global__ void FexKernel(realtype *y, realtype *ydot, NaunetData *d_udata,
                          int nsystem) {
    int tidx = blockIdx.x * blockDim.x + threadIdx.x;
    int gs   = blockDim.x * gridDim.x;

    for (int cur = tidx; cur < nsystem; cur += gs) {
        int yistart            = cur * NEQUATIONS;
        realtype *y_cur        = y + yistart;
        realtype k[NREACTIONS] = {0.0};
        NaunetData *udata      = &d_udata[cur];

        // clang-format off
        {% for v in variables.varis -%}
            realtype {{ v }} = udata->{{ v }};
        {% endfor %}

        {% for v in variables.tvaris -%}
            realtype {{ v }} = udata->{{ v }};
        {% endfor %}
        
        {% if variables.tvaris -%}
        if (mu < 0) mu = GetMu(y_cur);
        if (gamma < 0) gamma = GetGamma(y_cur);
        {% endif -%}

        // clang-format on

        EvalRates(k, y_cur, udata);

        // clang-format off
        {% for eq in ode.fex -%}
            {{ eq | replace("ydot[IDX", "ydot[yistart + IDX") | replace("y[IDX", "y_cur[IDX") | stmwrap(80, 12) }}
        {% endfor %}

        {% for m in ode.odemodifier -%}
            {{ m | replace("ydot[IDX", "ydot[yistart + IDX") | replace("y[IDX", "y_cur[IDX") }};
        {% endfor %}
        // clang-format on
    }
}

__global__ void JacKernel(realtype *y, realtype *data, NaunetData *d_udata,
                          int nsystem) {
    int tidx = blockIdx.x * blockDim.x + threadIdx.x;
    int gs   = blockDim.x * gridDim.x;

    for (int cur = tidx; cur < nsystem; cur += gs) {
        int yistart            = cur * NEQUATIONS;
        int jistart            = cur * NNZ;
        realtype *y_cur        = y + yistart;
        realtype k[NREACTIONS] = {0.0};
        NaunetData *udata      = &d_udata[cur];

        // clang-format off
        {% for v in variables.tvaris -%}
            realtype {{ v }} = udata->{{ v }};
        {% endfor %}
        
        {% if variables.tvaris -%}
        if (mu < 0) mu = GetMu(y_cur);
        if (gamma < 0) gamma = GetGamma(y_cur);
        {% endif -%}

        // clang-format on

        EvalRates(k, y_cur, udata);

        // clang-format off
        {% for data in ode.spjacdata -%}
            {{ data | replace("data[", "data[jistart + ") | replace("y[IDX", "y_cur[IDX") | stmwrap(80, 12) }}
        {% endfor %}
        // clang-format on
    }
}

/* {% else %} */
int Jtv(N_Vector v, N_Vector jv, realtype t, N_Vector u, N_Vector fu,
        void *user_data, N_Vector tmp) {
    realtype *x            = N_VGetArrayPointer(u);
    realtype *y            = N_VGetArrayPointer(v);
    realtype *ydot         = N_VGetArrayPointer(jv);
    realtype *fx           = N_VGetArrayPointer(fu);

    NaunetData *u_data     = (NaunetData *)user_data;
    // clang-format off
    {% for v in variables.varis -%}
        realtype {{ v }} = u_data->{{ v }};
    {% endfor %}

    {% for v in variables.tvaris -%}
        realtype {{ v }} = u_data->{{ v }};
    {% endfor %}

    {% if variables.tvaris -%}
    if (mu < 0) mu = GetMu(y);
    if (gamma < 0) gamma = GetGamma(y);
    {% endif -%}

    // clang-format on

    realtype k[NREACTIONS] = {0.0};
    EvalRates(k, y, u_data);

    // clang-format off
    {% for eq in ode.fex -%}
        {{ eq | stmwrap(80, 8) }}
    {% endfor %}

    {% for m in ode.odemodifier -%}
        {{ m }};
    {% endfor %}
    // clang-format on

    for (int i = 0; i < NEQUATIONS; i++) {
        fx[i] = 0.0;
    }

    return NAUNET_SUCCESS;
}

/* {% endif -%} */

int Fex(realtype t, N_Vector u, N_Vector udot, void *user_data) {
    /* {% if info.method == "dense" or info.method == "sparse" -%} */
    realtype *y            = N_VGetArrayPointer(u);
    realtype *ydot         = N_VGetArrayPointer(udot);
    NaunetData *u_data     = (NaunetData *)user_data;
    // clang-format off
    {% for v in variables.varis -%}
        realtype {{ v }} = u_data->{{ v }};
    {% endfor %}

    {% for v in variables.tvaris -%}
        realtype {{ v }} = u_data->{{ v }};
    {% endfor %}

    {% if variables.tvaris -%}
    if (mu < 0) mu = GetMu(y);
    if (gamma < 0) gamma = GetGamma(y);
    {% endif -%}

    // clang-format on

    realtype k[NREACTIONS] = {0.0};
    EvalRates(k, y, u_data);

    // clang-format off
    {% for eq in ode.fex -%}
        {{ eq | stmwrap(80, 8) }}
    {% endfor %}

    {% for m in ode.odemodifier -%}
        {{ m }};
    {% endfor %}

{% if variables.tvaris -%}
#if NAUNET_DEBUG
    printf("Total heating/cooling rate: %13.7e\n", ydot[IDX_TGAS]);
#endif
{% endif -%}

    // clang-format on

    /* {% elif info.method == "cusparse" -%} */

    realtype *y         = N_VGetDeviceArrayPointer_Cuda(u);
    realtype *ydot      = N_VGetDeviceArrayPointer_Cuda(udot);
    NaunetData *h_udata = (NaunetData *)user_data;
    NaunetData *d_udata;

    // check the size of system (number of cells/ a batch)
    sunindextype lrw, liw;
    N_VSpace_Cuda(u, &lrw, &liw);
    int nsystem = lrw / NEQUATIONS;

    // copy the user data for each system/cell
    cudaMalloc((void **)&d_udata, sizeof(NaunetData) * nsystem);
    cudaMemcpy(d_udata, h_udata, sizeof(NaunetData) * nsystem,
               cudaMemcpyHostToDevice);
    cudaDeviceSynchronize();

    unsigned block_size = min(BLOCKSIZE, nsystem);
    unsigned grid_size =
        max(1, min(MAXNGROUPS / BLOCKSIZE, nsystem / BLOCKSIZE));
    FexKernel<<<grid_size, block_size>>>(y, ydot, d_udata, nsystem);

    cudaDeviceSynchronize();
    cudaError_t cuerr = cudaGetLastError();
    if (cuerr != cudaSuccess) {
        fprintf(stderr, ">>> ERROR in fex: cudaGetLastError returned %s\n",
                cudaGetErrorName(cuerr));
        return -1;
    }
    cudaFree(d_udata);

    /* {% endif -%} */

    return NAUNET_SUCCESS;
}

int Jac(realtype t, N_Vector u, N_Vector fu, SUNMatrix jmatrix, void *user_data,
        N_Vector tmp1, N_Vector tmp2, N_Vector tmp3) {
    /* {% if info.method == "dense" -%} */
    realtype *y            = N_VGetArrayPointer(u);
    NaunetData *u_data     = (NaunetData *)user_data;
    // clang-format off
    {% for v in variables.varis -%}
        realtype {{ v }} = u_data->{{ v }};
    {% endfor %}

    {% for v in variables.tvaris -%}
        realtype {{ v }} = u_data->{{ v }};
    {% endfor %}
    
    {% if variables.tvaris -%}
    if (mu < 0) mu = GetMu(y);
    if (gamma < 0) gamma = GetGamma(y);
    {% endif -%}

    // clang-format on

    realtype k[NREACTIONS] = {0.0};
    EvalRates(k, y, u_data);

    // clang-format off
    {% for eq in ode.jac -%}
        {{ eq | stmwrap(80, 8) }}
    {% endfor %}  // clang-format on

    /* {% elif info.method == "sparse" -%} */
    realtype *y            = N_VGetArrayPointer(u);
    sunindextype *rowptrs  = SUNSparseMatrix_IndexPointers(jmatrix);
    sunindextype *colvals  = SUNSparseMatrix_IndexValues(jmatrix);
    realtype *data         = SUNSparseMatrix_Data(jmatrix);
    NaunetData *u_data     = (NaunetData *)user_data;

    // clang-format off
    {% for v in variables.tvaris -%}
        realtype {{ v }} = u_data->{{ v }};
    {% endfor %}
    
    {% if variables.tvaris -%}
    if (mu < 0) mu = GetMu(y);
    if (gamma < 0) gamma = GetGamma(y);
    {% endif -%}

    // clang-format on

    realtype k[NREACTIONS] = {0.0};
    EvalRates(k, y, u_data);

    // clang-format off
    // number of non-zero elements in each row
    {% for rptr in ode.spjacrptr -%}
        {{ rptr }}
    {% endfor %}

    // the column index of non-zero elements
    {% for cval in ode.spjaccval -%}
        {{ cval }}
    {% endfor %}

    // value of each non-zero element
    {% for data in ode.spjacdata -%}
        {{ data | stmwrap(80, 8) }}
    {% endfor %}

    // clang-format on

    /* {% elif info.method == "cusparse" -%} */
    realtype *y         = N_VGetDeviceArrayPointer_Cuda(u);
    realtype *data      = SUNMatrix_cuSparse_Data(jmatrix);
    NaunetData *h_udata = (NaunetData *)user_data;
    NaunetData *d_udata;

    int nsystem = SUNMatrix_cuSparse_NumBlocks(jmatrix);

    cudaMalloc((void **)&d_udata, sizeof(NaunetData) * nsystem);
    cudaMemcpy(d_udata, h_udata, sizeof(NaunetData) * nsystem,
               cudaMemcpyHostToDevice);
    cudaDeviceSynchronize();

    unsigned block_size = min(BLOCKSIZE, nsystem);
    unsigned grid_size =
        max(1, min(MAXNGROUPS / BLOCKSIZE, nsystem / BLOCKSIZE));
    JacKernel<<<grid_size, block_size>>>(y, data, d_udata, nsystem);

    cudaDeviceSynchronize();
    cudaError_t cuerr = cudaGetLastError();
    if (cuerr != cudaSuccess) {
        fprintf(stderr, ">>> ERROR in jac: cudaGetLastError returned %s\n",
                cudaGetErrorName(cuerr));
        return -1;
    }
    cudaFree(d_udata);

    /* {% endif -%} */

    return NAUNET_SUCCESS;
}
